大学A组C/C++
蓝桥杯知识点
（注：由于部分知识点已经学过了，只是简单的写了一些主要的记忆点，仅供参考！！！）
1.枚举
enum<类型名>{<枚举常量表>}；
定义枚举类型时可以指定部分或全部枚举常量的整数值，在指定整数值前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。（各枚举常量的值可以重复）


2.排序
(1)冒泡排序[2]
(2)选择排序[3]：每次找到最小元素放到前面
(3)插入排序[3]：将元素插入到已经排好序的队列中
(4)归并排序[4-5] ：将待排序列分成两份，分别对两份排序，再将他们合并
(5)快速排序[4-5] ：（基准）采用分治的思想进行排序
(6)桶排序[4] ：（适用于：输入数据服从均匀分布）将数据分到有限数量的桶里，每个桶再分别排序
(7)堆排序[4] ：基于二叉堆数据结构的比较排序算法，通过构造最小堆和最大堆，将堆顶元素和堆尾元素交换，然后重新调整堆，从而实现排序
(8)基数排序[4~5]：低位先排序，再按照高位排序

3.搜索
(1)BFS：适用于最短路径问题，使用队列实现
(2)DFS：适用于深度优先搜索，使用递归或栈实现
(3)剪枝[4-6] ：通过一些判断，砍掉搜索树上不必要的子树，提高搜索效率。这些子树可能是不必达的，也可能是可达但不是最优的，去掉它们堆最终答案没有影响
剪枝类型：
可行性剪枝：通过某种计算，判断出当前状态能否到达目标状态，如果不能达到目标状态则退出。
最优性剪枝：在搜索过程中，如果当前路径的代价已经超过了已知的最优解，则可以剪掉该路径。
(4)双向 BFS[5-6] ：从初始状态和目标状态两个方向同时搜索，故需要设置两个队列，搜索重合即搜索完毕；每次选择更小的队列进行扩展，直到两个队列中的结点相遇
(5)记忆化搜索[5] ：通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式
(6)迭代加深搜索[5-6] ：设置了深度限制的DFS
(7)启发式搜索[7]：启发式搜索是一种在普通搜索算法的基础上引入了启发式函数的搜索算法。启发式函数的作用是基于已有的信息对搜索的每一个分支进行评估，从而选择最优的分支进行扩展。这种搜索方法可以有效减少搜索空间，提高搜索效率。

（不一定是最优解）

4.贪心
贪心算法：每一步选择都采取当前状态下的最优的选择，从而希望导致结果是全局最优的算法
（不一定是最优解）

5.模拟
模拟算法：一种通过计算机模拟现实世界或抽象系统的行为和过程的算法。它通过逐步执行和记录系统状态的变化，来研究系统的动态行为和性能指标。模拟算法广泛应用于物理、化学、生物、工程、经济、社会学等多个领域。
建立模型->初始化->定义规则->逐步执行->记录结果->分析结果

6.二分

7.DP
(1)普通一维问题：一维动态规划问题通常涉及一个一维数组dp，其中dp[i]表示第i步的最优解
(2)背包 DP[4-6] ：背包问题涉及一个二维数组dp，其中dp[i][w]表示前i个物品在背包容量w时的最大价值
(3)树形 DP[4-6] ：树形DP涉及在树结构上进行动态规划，通常使用DFS来遍历树，并在递归过程中计算状态

(4)状压 DP[5-6] ：通过将状态压缩为一个整数来减少状态的数量，通常用于处理组合问题
(5)数位 DP[5-6] ：将数字分解为各位数字，逐位进行动态规划，通常用于处理数字范围内的计数问题
(6)DP 的常见优化[7]：通过优化状态转移和存储结构，减少动态规划的时间和空间复杂度
优化技巧：
空间优化：如果状态转移只依赖前几步状态，可以通过滚动数组将空间复杂度从O(n)降低到O(1)。
压缩维度：对于二维动态规划问题，可以压缩到一维数组进行状态存储。
减少不必要计算：通过提前剪枝，减少动态规划状态的计算范围。

8.高精度

9.数据结构
(1)栈[2-4]； 
(2)队列[2-5] 
(3)链表 [2-5]
(4)ST 表[5-6] ：一种用于高效处理区间查询的数据结构，主要用于解决可重复贡献问题（如区间最大值、最小值、最大公约数等）
(5)堆[5-6] 
(6)树状数组[5-6]
(7)线段树[6-7] ：一种高效的数据结构，用于解决区间查询和区间更新问题。它通过将整个区间递归地划分为更小的子区间，每个节点存储了对应区间的信息，从而实现了高效的区间查询和更新操作。

(8)Trie 树[5-7] ：Trie 树（字典树）是一种用于高效检索字符串数据集中的键的数据结构。它利用字符串的公共前缀来节约存储空间，并且可以快速地进行字符串的查找和插入操作。Trie 树通常用于实现字典、自动补全、拼写检查等功能。
(9)并查集[5-6] ：一种用于处理不相交集合的数据结构，主要用于解决一些图论中的问题，如连通性问题。它支持两个主要操作：查找（Find）和合并（Union）。
查找：查找某个元素所在的集合，通常通过路径压缩来优化查找操作，使得每次查找的时间复杂度接近O(1)。
合并：合并两个元素所在的集合，通常通过按秩合并来优化合并操作，使得树的高度保持较低。

(10)平衡树(利用系统自带的标准库实现简单平衡树)[5-7]：一种自平衡的二叉搜索树，确保树的高度始终保持在Olog(n),从而保证插入、删除和查找操作的时间复杂度为O(log n)。C++ 标准库中的std::set和std::map就是基于红黑树实现的平衡树。
(11)树链剖分[7-8] ：一种用于处理树上路径问题的数据结构，通过将树分解为若干条链，使得每条链上的节点可以高效地进行区间查询和更新操作。
剖分：将树分解成若干链条，每条链上的节点可以高效地进行区间查询和更新操作
区间查询：通过树链剖分，将路径分解为若干条链，每条链上的节点可以高效地进行区间查询操作。
(12)二维/动态开点线段树[7-8] ：一种用于处理二维区间查询和更新问题的数据结构。动态开点线段树是一种在插入和更新时动态创建节点的线段树，适用于处理动态区间问题。
(13)平衡树[8-9] 
(14)可持久化数据结构[8-9] ：一种能够在不破坏旧版本的前提下支持快速插入、删除等操作的数据结构。这种数据结构每次修改都会保留其自身每一个历史版本，并且支持操作的不可变特性（immutable）
可持久化数据结构的核心思想是利用结构共享，即在修改数据结构时，只新建发生改变的节点，保留其余节点。这种方法不仅节省空间，还能保证操作的高效性。
分类：
部分可持久化：所有版本都可以访问，但只有最新版本可以修改
完全可持久化：所有版本都可以访问和修改
融合可持久化：允许合并历史版本
应用：
几何计算、字符串处理、版本回溯
(15)树套树[9-10] 
1. 定义
树套树是一种将两种或多种树形数据结构结合起来的数据结构，旨在解决一些单独无法解决的问题。常见的组合包括线段树套平衡树、树状数组套动态开点权值线段树等。
2. 原理
树套树的原理是利用外层树的树高为O(log n)和内层树允许动态开点的性质。具体来说，进行一次单点修改，对应就是在外层树对应点的所有祖先分别进行一次内层树的修改。由于树高的限制，这样一次的时间复杂度为O(log^2 n)。对于一次区间查询，利用线段树/平衡树的性质分到外层树的O(log n)个节点上，对于这些节点对应的内层树分别进行查询，同样时间复杂度也为O(log^2 n)。
3. 常见的树套树实现
3.1 线段树套平衡树
外层套一个线段树，用来维护整体的序列；内层套一个平衡树，用来维护集合，搞平衡树操作。对于每个操作，把它分割成一堆小段（线段树操作），然后对于每一个操作进行查询/维护，然后合并。
3.2 树状数组套动态开点权值线段树
树状数组的每个节点上挂一个权值线段树，用于处理二维信息，特别是单点修改和矩形查询问题。

(16)动态树[9-10]：一种用于维护和操作动态变化的树结构的数据结构。它支持对树的分割、合并、路径操作和子树操作等。动态树问题通常要求维护一个由若干棵子节点无序的有根树组成的森林，并支持对树的分割（删边）、合并（加边）、对某个点到它的根的路径的某些操作（路径操作）

10.数学
(1)初等数论：研究整数的可除性、同余关系、素数分布、整数的表示和分解等
(2)排列组合[5-6] 
(3)二项式定理[6] 
(4)容斥原理[6-7] ：|A ∪ B| = |A| + |B| - |A ∩ B|
(5)模意义下的逆元[5] ：在模m的意义下，整数a的逆元b满足a * b ≡ 1 (mod m)
(6)矩阵运算[6-7] 
(7)高斯消元[7]：高斯消元是一种用于求解线性方程组的算法，通过将方程组的增广矩阵化为行阶梯形矩阵来求解。（消元、回代）
(8)生成函数[8-10] ：表示数列的函数
(9)莫比乌斯反演[8-10] ：莫比乌斯反演是一种用于数论的反演公式，通过莫比乌斯函数将两个数列联系起来。

(10)快速傅里叶变换[9-10]：快速傅里叶变换（FFT）是一种用于计算离散傅里叶变换（DFT）的快速算法，通过利用DFT的对称性和周期性来减少计算量。（分解、合并）

11.字符串
(1)哈希[4-5] 
(2)kmp[4-6]
(3)manacher[4-6]：一种用于在时间复杂度和空间复杂度都是O(n)的情况下求出一个字符串的最长回文子串长度的算法。该算法通过在字符串中插入特殊字符，将奇数长度和偶数长度的回文子串统一处理，从而避免了中心扩展法中需要分别处理奇偶长度的问题。
(4)AC 自动机[7-8] ：一种用于多模式匹配的字符串搜索算法。它结合了 Trie 树和 KMP 算法的优点，能够在给定的文本中同时搜索多个模式串，并且在最坏情况下的时间复杂度为O(n + m + z)，其中n是文本长度，m是所有模式串的总长度，z是匹配到的子串数量。
(5)拓展 kmp[7-8] ：一种用于字符串匹配的算法，能够在O(n)的时间复杂度内计算出一个字符串在另一个字符串中的所有出现位置。它通过预处理模式串，计算出一个 Z 数组，Z 数组的每个元素Z[i]表示从位置i开始的子串与模式串的最长公共前缀长度。
(6)后缀数组[8-10] ：一种用于字符串处理的数据结构，通过将字符串的所有后缀进行排序，可以高效地解决字符串的最长公共前缀（LCP）问题、子串查找等问题。
(7)后缀自动机[8-10] ：一种用于处理字符串的数据结构，能够在O(n)的时间复杂度内构建，并且支持高效地查找子串、计算不同子串的数量等操作。
(8)回文自动机[8-10]：一种可以存储一个串中所有回文子串的高效数据结构。它能够在O(n)的时间复杂度内求出字符串的所有回文子串。回文自动机由两棵树组成，一棵树中的节点对应的回文子串长度均为奇数，另一棵树中的节点对应的回文子串长度均为偶数。

12.图论
（1）欧拉回路[5-7] 
（2）最小生成树[5-7] 
（3）单源最短路及差分约束系统[5-7] ：最短路径算法（Dijkstra算法和Ford算法）
（4）拓扑序列[5-7] 
（5）二分图匹配[7]：二分图是一个图，其顶点可以分为两个不相交的集合，使得同一集合内的任意两个顶点之间没有边相连。匹配是指图中边的一个子集，使得任意两条边都不相邻（即没有公共顶点） 
（6）图的连通性问题（割点、桥、强连通分量）[7] 
（7）DFS 序[5-7] 
（8）最近共同祖先[5-7]：（LCA）指在有根树中，两个节点u和v的最近公共祖先是最深的节点w，使得w同时是u和v的祖先。（Tarjan算法、倍增法）
（9）网络流[8-10] ：是在给定的流网络中找到一个流，使得从源点到汇点的流量最大。常见的算法有 Ford-Fulkerson 算法和 Dinic 算法。
（10）一般图匹配[9-10]：指在一般图中找到一个匹配，使得匹配中的边数最多。一般图匹配问题比二分图匹配问题更复杂，常见的算法有 Edmonds 算法。（Edmonds 算法通过寻找增广路径和花（blossom）来求解一般图匹配问题，时间复杂度为O(n^3)。）

13.计算几何
（1）基础计算和基本位置关系判定[6-7] ：坐标表示等
（2）概率论[7+] 
（3）博弈论[7+]：博弈论是研究决策问题的数学分支，它在计算几何中用于处理几何对象的最优策略和最优解。
